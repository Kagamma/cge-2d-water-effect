#X3D V4.0 utf8
PROFILE Interchange

Transform {
  scale 100 100 1
  children Shape {
    appearance Appearance {
      material UnlitMaterial {
        transparency 0.7
        emissiveColor 1 1 1
      }
      shaders DEF waterShader ComposedShader {
        language "GLSL"
        initializeOnly SFNode texWaterNormal ImageTexture { url "waternormal.png" }
        initializeOnly SFNode texWaterDUDV ImageTexture { url "waterdudv.png" }
        initializeOnly SFInt32 texPreviousScreen 15
        initializeOnly SFInt32 texCurrentScreen 7
        initializeOnly SFFloat speed 0.08
        initializeOnly SFFloat waveStrength 0.02
        initializeOnly SFFloat waveStrengthNormal 0.1
        initializeOnly SFFloat waveStrengthRelect 0.01
        initializeOnly SFFloat waveStrengthRefract 0.005
        initializeOnly SFFloat zoom 0.005
        initializeOnly SFFloat range 30
        initializeOnly SFFloat fadeNormal 2
        initializeOnly SFFloat fadeDeep 0.2
        initializeOnly SFFloat fadeReflect 4.0
        initializeOnly SFFloat fadeRefract 0.2
        initializeOnly SFFloat foamThickness 0.06
        initializeOnly SFVec3f colorWater 0.7 0.7 0.9
        initializeOnly SFVec3f colorFoam 0.7 0.7 0.7
        inputOnly SFTime time
        parts [
          ShaderPart {
            type "VERTEX"
            url "data:text/plain,
uniform mat4 castle_ModelViewMatrix;
uniform mat4 castle_ProjectionMatrix;

attribute vec4 castle_Vertex;
attribute vec4 castle_MultiTexCoord0;

varying vec4 fragTexcoord;
varying vec2 fragPos;
varying vec2 fragPosViewport;
varying float fragSurfaceViewport;
varying vec2 fragScale;

void main() {
  fragTexcoord = castle_MultiTexCoord0;
  fragPos = castle_Vertex.xy;
  fragScale = vec2(castle_ModelViewMatrix[0][0], castle_ModelViewMatrix[1][1]);
  mat4 mvp = castle_ProjectionMatrix * castle_ModelViewMatrix;
  gl_Position = mvp * castle_Vertex;
  vec4 maxPosition = mvp * vec4(1.0, 1.0, 0.0, 1.0);
  fragPosViewport = (gl_Position.xy / gl_Position.w) * 0.5 + 0.5;
  fragSurfaceViewport = (maxPosition.y / maxPosition.w) * 0.5 + 0.5;
}"
          }

          ShaderPart {
            type "FRAGMENT"
            url "data:text/plain,
uniform float time;
uniform float speed;
uniform float waveStrength;
uniform float waveStrengthNormal;
uniform float waveStrengthRelect;
uniform float waveStrengthRefract;
uniform float zoom;
uniform float range;
uniform float fadeNormal;
uniform float fadeDeep;
uniform float fadeReflect;
uniform float fadeRefract;
uniform float foamThickness;
uniform float foamDeep;
uniform vec3 colorWater;
uniform vec3 colorFoam;
uniform sampler2D texWaterNormal;
uniform sampler2D texWaterDUDV;
uniform sampler2D texPreviousScreen;
uniform sampler2D texCurrentScreen;

varying vec4 fragTexcoord;
varying vec2 fragPos;
varying vec2 fragPosViewport;
varying float fragSurfaceViewport;
varying vec2 fragScale;

float norm(float val, float min, float max) {
  return (val - min) / (max - min);
}

void main() {
  vec3 lightDir = vec3(0.0, -0.707, 0.707);
  vec2 coord = vec2(fragPos.x * fragScale.x * zoom, fragTexcoord.y * fragScale.y * zoom - (fragScale.y * zoom - 1.0));
  vec2 reflectCoord = vec2(
    fragPosViewport.x - waveStrengthRelect + (fragSurfaceViewport - fragPosViewport.y) * 0.2,
    fragSurfaceViewport * 2.0 - fragPosViewport.y
  );
  vec2 refractCoord = vec2(fragPosViewport.x, fragPosViewport.y);
  float spd = time * speed;

  vec2 nd1 = texture2D(texWaterDUDV, vec2(coord.x + spd, coord.y)).xy * waveStrengthNormal;
  nd1 = coord + vec2(nd1.x - spd, nd1.y - spd);

  vec3 normal = texture2D(texWaterNormal, nd1).xyz;
  vec3 lightReflDir = reflect(lightDir, normal) * coord.y;
  float spec = pow(max(dot(lightDir, lightReflDir), 0.0), range);

  vec2 rd1 = texture2D(texWaterDUDV, vec2(coord.x + spd, coord.y)).xy;
  vec2 rd2 = texture2D(texWaterDUDV, vec2(-coord.x + spd, coord.y + spd)).xy;
  vec2 rd3 = rd1 + rd2;
  vec3 reflectColor = texture2D(texPreviousScreen, clamp(reflectCoord + rd3 * waveStrengthRelect, 0.0, 1.0)).xyz;
  vec3 refractColor = texture2D(texCurrentScreen, clamp(refractCoord + rd3 * waveStrengthRefract, 0.0, 1.0)).xyz;

  vec3 colorDefault = mix(colorWater * pow(fragTexcoord.y, fadeDeep), reflectColor, pow(fragTexcoord.y, fadeReflect));
  vec3 color = max(sign(coord.y - 1.0), 0.0) * colorDefault + fadeNormal * spec;
  color += max(sign(1.0 - coord.y), 0.0) * colorDefault;

  float wave = rd3.x * waveStrength;
  float nearSurface = clamp((1.0 - coord.y) + wave, 0.0, 1.0);
  color += max(sign(foamThickness * 2.0 - nearSurface), 0.0) * mix(vec4(0.0), colorFoam, clamp(norm(coord.y, 1.0 - foamThickness * 0.5 - wave, 1.0), 0.0, 1.0));

  gl_FragColor = max(sign(nearSurface - wave * 2.0), 0.0) * vec4(mix(color, refractColor, fadeRefract), 1.0);
}"
          }
        ]
      }
    }
    geometry IndexedFaceSet {
      coord Coordinate {
        point [
          0 0 0
          1 0 0
          1 1 0
          0 1 0
        ]
      }
      coordIndex [0 1 2 3]
      texCoord TextureCoordinate {
        point [
          0 0
          1 0
          1 1
          0 1
        ]
      }
      solid FALSE
    }
  }
}

DEF proximitySensor ProximitySensor { size 10000000 10000000 10000000 }
DEF timer TimeSensor {
  loop TRUE
}
ROUTE proximitySensor.enterTime TO timer.startTime
ROUTE timer.elapsedTime TO waterShader.time